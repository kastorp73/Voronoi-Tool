<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Voronoi Diagram Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">
    <div id="app" class="flex flex-col h-screen max-h-screen">
        <header id="toolbar" class="bg-gray-800 text-white p-2 flex flex-wrap items-center gap-x-4 gap-y-2 text-sm z-10 shadow-md">
            <div class="font-bold text-lg">Voronoi Tool</div>
            <div>Points: <span id="point-count">0</span></div>

            <div class="flex items-center gap-x-3">
                <span class="font-semibold">Display:</span>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="showFill" id="show-fill-checkbox" checked /> Fill</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="showEdges" id="show-edges-checkbox" checked /> Edges</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="showSites" id="show-sites-checkbox" checked /> Sites</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="showHeatmap" id="show-heatmap-checkbox" /> Heatmap</label>
                <label class="flex items-center gap-1 cursor-pointer"><input type="checkbox" name="showDelaunay" id="show-delaunay-checkbox" /> Delaunay</label>
            </div>

            <div class="flex items-center gap-2">
                <label for="edit-mode-select" class="font-semibold">Mode:</label>
                <select id="edit-mode-select" class="bg-gray-700 rounded p-1 border border-gray-600">
                    <option value="points">Edit Points</option>
                    <option value="pan" selected>Pan & Zoom</option>
                    <option value="addCircle">Add Circle</option>
                    <option value="addGrid">Add Grid</option>
                    <option value="addPolygon">Add Polygon</option>
                </select>
            </div>

            <div class="flex items-center gap-2">
                <label class="font-semibold">Material:</label>
                <div id="material-selector" class="flex gap-1">
                    <!-- Material buttons will be generated by JS -->
                </div>
            </div>

            <div class="flex flex-wrap gap-2">
                <button id="undo-btn" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">Undo</button>
                <button id="redo-btn" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">Redo</button>
                <button id="voxelize-btn" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded transition-colors">Voxelize</button>
                <button id="cull-btn" class="bg-yellow-600 text-black hover:bg-yellow-500 px-3 py-1 rounded transition-colors">Cull Redundant</button>
                <button id="clear-btn" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded transition-colors">Clear All</button>
                <button id="reset-view-btn" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded transition-colors">Reset View</button>
                <button id="help-btn" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded transition-colors">Help</button>
                <button id="export-btn" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded transition-colors">Export JSON</button>
                <button id="import-btn" class="bg-purple-600 hover:bg-purple-700 px-3 py-1 rounded transition-colors">Import JSON</button>
                <input type="file" id="import-input" accept=".json,application/json" style="display: none;" />
            </div>

            <details id="generator-details" class="bg-gray-700 p-2 rounded w-full">
                <summary class="cursor-pointer font-semibold">Generator Parameters</summary>
                <div id="generator-params-container" class="flex flex-wrap items-start gap-x-6 gap-y-3 mt-2 p-2 bg-gray-900/50 rounded">
                    <!-- Generator params will be generated by JS based on mode -->
                </div>
            </details>
        </header>
        <main class="flex-grow flex flex-col min-h-0">
            <div id="canvas-container" class="w-full flex-grow relative min-h-0">
                <canvas id="voronoi-canvas"></canvas>
            </div>
        </main>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full p-6 relative">
            <button id="close-modal-btn" class="absolute top-2 right-3 text-gray-400 hover:text-white text-3xl font-bold" aria-label="Close help">&times;</button>
            <h3 class="text-xl font-semibold mb-3">Notes</h3>
            <ul class="list-disc list-inside space-y-3 text-gray-300">
                <li><b>Pan & Zoom Mode</b>: Use mouse wheel to zoom (cursor-centered) and drag to pan.</li>
                <li><b>Point Editing Mode</b>: Drag to move points. Double-click to add a point with the selected material. Single-click a point to change its material. <kbd class="px-2 py-1 text-xs font-semibold text-gray-200 bg-gray-700 border border-gray-600 rounded-md">Alt</kbd> + click to remove points.</li>
                <li><b>Add Shape Modes (Circle, Grid, Polygon)</b>:
                    <ul class="list-['–'] list-inside ml-4 mt-2 space-y-1 text-gray-400">
                        <li>Select a mode to see a live preview of the shape follow your cursor. Click to place it.</li>
                        <li>Use the <kbd class="px-2 py-1 text-xs font-semibold text-gray-200 bg-gray-700 border border-gray-600 rounded-md">Arrow Keys</kbd> to adjust shape parameters in real-time while previewing.</li>
                        <li><b>Polygon Specifics</b>: Left-click to add vertices. Click near the first vertex to close the polygon. Right-click to cancel the current shape.</li>
                    </ul>
                </li>
                <li><b>Generator Parameters</b>: Fine-tune shapes before placing them in the parameters panel. Key options include:
                    <ul class="list-['–'] list-inside ml-4 mt-2 space-y-1 text-gray-400">
                        <li><b>Overwrite Existing</b>: When checked, removes any old points that are inside the new shape's area.</li>
                        <li><b>Radial Alignment (Circle)</b>: Aligns points on concentric circles into spoke-like rays.</li>
                        <li><b>Reduce Points (Grid)</b>: Creates a minimal grid outline instead of a full grid.</li>
                        <li><b>Split Edges (Polygon)</b>: Adds intermediate points along long polygon edges for a more stable Voronoi wall. (Not used in Ring mode).</li>
                        <li><b>Generate as Ring (Polygon)</b>: Creates a three-layer wall of points along the polygon edges instead of using corner-based logic.</li>
                    </ul>
                </li>
                <li><b>Import/Export</b>: Use the buttons in the toolbar to load points from a JSON file or save the current set of points to a file.</li>
                <li><b>Voxelize Current Points</b>: Creates a new 20x20 grid, snapping each cell's point to the nearest original point.</li>
                <li><b>Remove Redundant</b>: Deletes points that are completely surrounded by neighbors of the same material.</li>
                <li><b>Voronoi</b>: Cells are calculated by clipping the canvas rectangle with perpendicular bisectors.</li>
            </ul>
        </div>
    </div>


    <script>

function lineIntersect(p, q, a, b, c) {
  const dx = q[0] - p[0];
  const dy = q[1] - p[1];
  const denom = a * dx + b * dy;
  if (Math.abs(denom) < 1e-9) return null;
  const t = (c - a * p[0] - b * p[1]) / denom;
  return [p[0] + t * dx, p[1] + t * dy];
}

function lineLineIntersection(p1, v1, p2, v2) {
    const x1 = p1[0], y1 = p1[1];
    const x2 = p1[0] + v1[0], y2 = p1[1] + v1[1];
    const x3 = p2[0], y3 = p2[1];
    const x4 = p2[0] + v2[0], y4 = p2[1] + v2[1];

    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (Math.abs(den) < 1e-9) return null; // Lines are parallel

    const t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4);
    const t = t_num / den;
    
    const px = x1 + t * (x2 - x1);
    const py = y1 + t * (y2 - y1);
    
    return [px, py];
}


function clipPolygon(poly, a, b, c) {
  if (!poly || poly.length === 0) return [];
  const out = [];
  for (let i = 0; i < poly.length; i++) {
    const P = poly[i];
    const Q = poly[(i + 1) % poly.length];
    const inP = a * P[0] + b * P[1] <= c + 1e-9;
    const inQ = a * Q[0] + b * Q[1] <= c + 1e-9;
    if (inP && inQ) {
      out.push(Q);
    } else if (inP && !inQ) {
      const I = lineIntersect(P, Q, a, b, c);
      if (I) out.push(I);
    } else if (!inP && inQ) {
      const I = lineIntersect(P, Q, a, b, c);
      if (I) out.push(I);
      out.push(Q);
    }
  }
  return out;
}

function voronoiCell(i, pts, bbox) {
  const p = pts[i];
  let poly = [[bbox.x0, bbox.y0], [bbox.x1, bbox.y0], [bbox.x1, bbox.y1], [bbox.x0, bbox.y1]];
  for (let j = 0; j < pts.length; j++) {
    if (j !== i) {
      const q = pts[j];
      const nx = q[0] - p[0];
      const ny = q[1] - p[1];
      const mx = 0.5 * (p[0] + q[0]);
      const my = 0.5 * (p[1] + q[1]);
      const c = nx * mx + ny * my;
      poly = clipPolygon(poly, nx, ny, c);
      if (poly.length === 0) break;
    }
  }
  return poly;
}

function computeVoronoi(pts, bbox) {
  if (!bbox || bbox.x1 <= 0 || bbox.y1 <= 0) return [];
  const out = [];
  for (let i = 0; i < pts.length; i++) {
    out.push(voronoiCell(i, pts, bbox));
  }
  return out;
}

const MATERIAL_COLORS = [
  '#A0A0A0', '#ff0000', '#00ff00', '#0000ff',
  '#ffff00', '#ff00ff', '#00ffff', '#ffffff'
];

// --- STATE MANAGEMENT ---
const appState = {
  points: [],
  viewState: { scale: 1, tx: 0, ty: 0 },
  displayOptions: {
    showFill: true,
    showEdges: true,
    showSites: true,
    showHeatmap: false,
    showDelaunay: false,
    editMode: 'pan',
  },
  generatorParams: {
    step: 20, rMin: 4, rMax: 6, spacing: 1,
    angle: -30, nx: 25, ny: 4, radialAlignment: true,
    reducePoints: false, polygonPointDistance: 20,
    splitEdges: true, overwrite: true, polygonRing: false,
  },
  canvasSize: { width: 800, height: 400 },
  currentMaterial: 1,
  cells: [],
  previewPoints: null,
};

const interactionState = {
  draggingPointIndex: -1,
  isPanning: false,
  lastPanPosition: { x: 0, y: 0 },
  isDragging: false,
  mouseDownPosition: { x: 0, y: 0 },
  mouseWorldPos: { x: 0, y: 0 },
};

const polygonCreationState = {
    points: [],
};

const SCALE_MIN = 0.25;
const SCALE_MAX = 8;
const CLICK_DRAG_THRESHOLD = 5;

// --- HISTORY (Undo/Redo) ---
const history = {
  states: [[]],
  index: 0,
  limit: 11,
  setState(newPoints) {
    const newHistory = this.states.slice(0, this.index + 1);
    const copiedPoints = JSON.parse(JSON.stringify(newPoints));
    newHistory.push(copiedPoints); 
    if (newHistory.length > this.limit) {
      newHistory.shift();
    }
    this.states = newHistory;
    this.index = this.states.length - 1;
    appState.points = copiedPoints;
    updateApp();
  },
  undo() {
    if (this.canUndo()) {
      this.index--;
      appState.points = JSON.parse(JSON.stringify(this.states[this.index]));
      updateApp();
    }
  },
  redo() {
    if (this.canRedo()) {
      this.index++;
      appState.points = JSON.parse(JSON.stringify(this.states[this.index]));
      updateApp();
    }
  },
  canUndo() { return this.index > 0; },
  canRedo() { return this.index < this.states.length - 1; },
};

// --- DOM ELEMENTS ---
const canvas = document.getElementById('voronoi-canvas');
const ctx = canvas.getContext('2d');
const canvasContainer = document.getElementById('canvas-container');
// Toolbar elements
const pointCountEl = document.getElementById('point-count');
const undoBtn = document.getElementById('undo-btn');
const redoBtn = document.getElementById('redo-btn');
const editModeSelect = document.getElementById('edit-mode-select');
const materialSelector = document.getElementById('material-selector');
const genParamsContainer = document.getElementById('generator-params-container');
// Modal elements
const helpBtn = document.getElementById('help-btn');
const helpModal = document.getElementById('help-modal');
const closeModalBtn = document.getElementById('close-modal-btn');


// --- UTILITY FUNCTIONS ---
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const screenToWorld = (x, y, vs) => [(x - vs.tx) / vs.scale, (y - vs.ty) / vs.scale];

// --- RENDERING ---
function draw() {
  const dpr = window.devicePixelRatio || 1;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  ctx.save();
  ctx.setTransform(dpr * appState.viewState.scale, 0, 0, dpr * appState.viewState.scale, appState.viewState.tx * dpr, appState.viewState.ty * dpr);

  const isPreview = !!appState.previewPoints;
  const pointsToRender = isPreview ? [...appState.points, ...appState.previewPoints] : appState.points;
  let cellsToRender;
  
  const bbox = { x0: 0, y0: 0, x1: appState.canvasSize.width, y1: appState.canvasSize.height };
  if (isPreview) {
      cellsToRender = computeVoronoi(pointsToRender, bbox);
  } else {
      cellsToRender = appState.cells;
  }

  // Heatmap
  if (appState.displayOptions.showHeatmap) {
      const S = 20, COLS = Math.ceil(appState.canvasSize.width / S), ROWS = Math.ceil(appState.canvasSize.height / S);
      const counts = new Uint16Array(COLS * ROWS);
      for (const p of pointsToRender) {
          const xi = Math.floor(p[0] / S), yi = Math.floor(p[1] / S);
          if (xi >= 0 && xi < COLS && yi >= 0 && yi < ROWS) counts[yi * COLS + xi]++;
      }
      for (let yi = 0; yi < ROWS; yi++) {
          for (let xi = 0; xi < COLS; xi++) {
              const c = counts[yi * COLS + xi];
              if (c === 0) ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
              else if (c === 1) ctx.fillStyle = 'rgba(0, 200, 0, 0.5)';
              else ctx.fillStyle = 'rgba(255, 220, 0, 0.5)';
              ctx.fillRect(xi * S, yi * S, S, S);
          }
      }
  }
  
  // Fill
  if (appState.displayOptions.showFill) {
      for (let i = 0; i < cellsToRender.length; i++) {
          const poly = cellsToRender[i];
          if (!poly || poly.length < 3) continue;
          const mat = (pointsToRender[i] && pointsToRender[i].length >= 3) ? pointsToRender[i][2] : 1;
          ctx.fillStyle = MATERIAL_COLORS[mat] || MATERIAL_COLORS[0];
          ctx.beginPath();
          ctx.moveTo(poly[0][0], poly[0][1]);
          for (let k = 1; k < poly.length; k++) ctx.lineTo(poly[k][0], poly[k][1]);
          ctx.closePath();
          ctx.fill();
      }
  }

  // Edges
  if (appState.displayOptions.showEdges) {
      ctx.lineWidth = 1 / (appState.viewState.scale * dpr);
      ctx.strokeStyle = '#99ddff';
      for (const poly of cellsToRender) {
          if (!poly || poly.length < 2) continue;
          ctx.beginPath();
          ctx.moveTo(poly[0][0], poly[0][1]);
          for (let k = 1; k < poly.length; k++) ctx.lineTo(poly[k][0], poly[k][1]);
          ctx.closePath();
          ctx.stroke();
      }
  }

  // Delaunay
  if (appState.displayOptions.showDelaunay) {
      ctx.lineWidth = 1 / (appState.viewState.scale * dpr);
      ctx.strokeStyle = '#99ddff'; // amber-500
      ctx.setLineDash([2 / appState.viewState.scale, 2 / appState.viewState.scale]);
      for (let i = 0; i < cellsToRender.length; i++) {
          const poly = cellsToRender[i];
          const site = pointsToRender[i];
          if (!poly || poly.length < 1 || !site) continue;
          for (const vertex of poly) {
              ctx.beginPath();
              ctx.moveTo(site[0], site[1]);
              ctx.lineTo(vertex[0], vertex[1]);
              ctx.stroke();
          }
      }
      ctx.setLineDash([]); // Reset for other drawing operations
  }
  
  // Sites
  if (appState.displayOptions.showSites) {
      const r = 3 / (appState.viewState.scale * dpr);
      for (const p of pointsToRender) {
          let pointColor = '#ffffff'; // Default color
          if (!appState.displayOptions.showFill) {
              const mat = p[2] ?? 0;
              pointColor = MATERIAL_COLORS[mat] || MATERIAL_COLORS[0];
          }
          ctx.fillStyle = pointColor;
          ctx.beginPath();
          ctx.arc(p[0], p[1], r, 0, Math.PI * 2);
          ctx.fill();
      }
  }

  // Polygon Creation Preview
  if (appState.displayOptions.editMode === 'addPolygon' && polygonCreationState.points.length > 0) {
      ctx.strokeStyle = '#4f85ff';
      ctx.lineWidth = 2 / (appState.viewState.scale * dpr);
      ctx.beginPath();
      ctx.moveTo(polygonCreationState.points[0][0], polygonCreationState.points[0][1]);
      for (let i = 1; i < polygonCreationState.points.length; i++) {
          ctx.lineTo(polygonCreationState.points[i][0], polygonCreationState.points[i][1]);
      }
      ctx.stroke();

      // Rubber band line to cursor
      const lastPoint = polygonCreationState.points[polygonCreationState.points.length - 1];
      ctx.beginPath();
      ctx.moveTo(lastPoint[0], lastPoint[1]);
      ctx.lineTo(interactionState.mouseWorldPos.x, interactionState.mouseWorldPos.y);
      ctx.stroke();
      
      // Highlight first point for closing
      ctx.fillStyle = '#4f85ff';
      ctx.beginPath();
      ctx.arc(polygonCreationState.points[0][0], polygonCreationState.points[0][1], 8 / (appState.viewState.scale * dpr), 0, Math.PI * 2);
      ctx.fill();
  }

  ctx.restore();
}

function updateApp() {
  // Update UI elements
  pointCountEl.textContent = appState.points.length;
  undoBtn.disabled = !history.canUndo();
  redoBtn.disabled = !history.canRedo();
  document.querySelectorAll('#material-selector button').forEach((btn, i) => {
      btn.classList.toggle('!border-white', i === appState.currentMaterial);
      btn.classList.toggle('ring-2', i === appState.currentMaterial);
  });

  // Re-calculate cells if points have changed
  const bbox = { x0: 0, y0: 0, x1: appState.canvasSize.width, y1: appState.canvasSize.height };
  appState.cells = computeVoronoi(appState.points, bbox);
  
  // Re-draw canvas
  draw();
}

// --- CANVAS EVENT HANDLERS ---
canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    interactionState.mouseDownPosition = { x: sx, y: sy };
    interactionState.isDragging = false;

    if (appState.displayOptions.editMode === 'pan') {
        interactionState.isPanning = true;
        interactionState.lastPanPosition = { x: sx, y: sy };
        canvas.style.cursor = 'grabbing';
        return;
    }

    if (appState.displayOptions.editMode === 'points') {
        const [xw, yw] = screenToWorld(sx, sy, appState.viewState);
        if (e.altKey) { // Remove point
            let best = -1, bdSq = Infinity;
            for (let i = 0; i < appState.points.length; i++) {
                const dSq = (appState.points[i][0] - xw) ** 2 + (appState.points[i][1] - yw) ** 2;
                if (dSq < bdSq) { bdSq = dSq; best = i; }
            }
            if (best >= 0 && bdSq < (20 / appState.viewState.scale) ** 2) {
                const newPoints = appState.points.filter((_, i) => i !== best);
                history.setState(newPoints);
            }
            return;
        }

        let best = -1, bd = Infinity; // Find point to drag
        for (let i = 0; i < appState.points.length; i++) {
            const d = Math.hypot(appState.points[i][0] - xw, appState.points[i][1] - yw);
            if (d < bd) { bd = d; best = i; }
        }
        if (best >= 0 && bd < (20 / appState.viewState.scale)) {
            interactionState.draggingPointIndex = best;
        }
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const [xw, yw] = screenToWorld(sx, sy, appState.viewState);
    interactionState.mouseWorldPos = { x: xw, y: yw };

    if (appState.displayOptions.editMode === 'addPolygon') {
        draw();
    } else if (e.buttons === 0 && (appState.displayOptions.editMode === 'addCircle' || appState.displayOptions.editMode === 'addGrid')) {
        if (appState.displayOptions.editMode === 'addCircle') {
            appState.previewPoints = buildConcentricTemplate(xw, yw);
        } else { // addGrid
            const { angle, step, nx, ny } = appState.generatorParams;
            appState.previewPoints = buildRotGridTemplate(angle * Math.PI / 180, step, nx, ny, xw, yw, appState.currentMaterial);
        }
        draw();
    }
    
    if (interactionState.isPanning && e.buttons === 1) {
        const dx = sx - interactionState.lastPanPosition.x;
        const dy = sy - interactionState.lastPanPosition.y;
        interactionState.lastPanPosition = { x: sx, y: sy };
        appState.viewState.tx += dx;
        appState.viewState.ty += dy;
        draw();
        return;
    }

    if (interactionState.draggingPointIndex < 0) return;

    if (e.buttons !== 1) { // Mouse button released outside canvas, reset
      handleMouseUp(true);
      return;
    }

    const dist = Math.hypot(sx - interactionState.mouseDownPosition.x, sy - interactionState.mouseDownPosition.y);
    if (dist > CLICK_DRAG_THRESHOLD) {
        interactionState.isDragging = true;
    }

    if (interactionState.isDragging) {
        const newPoints = JSON.parse(JSON.stringify(appState.previewPoints ?? appState.points));
        const p = newPoints[interactionState.draggingPointIndex];
        newPoints[interactionState.draggingPointIndex] = [
            clamp(xw, 0, appState.canvasSize.width),
            clamp(yw, 0, appState.canvasSize.height),
            p[2]
        ];
        appState.previewPoints = newPoints;
        draw();
    }
});

const handleMouseUp = (isMouseLeave = false) => {
    if (isMouseLeave && appState.displayOptions.editMode !== 'points') {
        appState.previewPoints = null;
    }

    if (interactionState.isDragging && appState.previewPoints) {
        history.setState(appState.previewPoints);
    } else if (appState.displayOptions.editMode === 'points' && interactionState.draggingPointIndex >= 0 && !interactionState.isDragging) {
        const newPoints = JSON.parse(JSON.stringify(appState.points));
        const p = newPoints[interactionState.draggingPointIndex];
        newPoints[interactionState.draggingPointIndex] = [p[0], p[1], appState.currentMaterial];
        history.setState(newPoints);
    } else if (!isMouseLeave && interactionState.draggingPointIndex < 0 && !interactionState.isDragging) {
        const [xw, yw] = screenToWorld(interactionState.mouseDownPosition.x, interactionState.mouseDownPosition.y, appState.viewState);
        if (appState.displayOptions.editMode === 'addCircle' || appState.displayOptions.editMode === 'addGrid') {
            handleAddShape(xw, yw);
        } else if (appState.displayOptions.editMode === 'addPolygon') {
            handleAddPolygonPoint(xw, yw);
        }
    }
    appState.previewPoints = null;
    interactionState.draggingPointIndex = -1;
    interactionState.isPanning = false;
    interactionState.isDragging = false;
    canvas.style.cursor = getCursorStyle();
    
    // Always updateApp on mouseup unless it's a mouseleave during a non-drag
    if (!(isMouseLeave && !appState.previewPoints)) {
        updateApp();
    }
};
canvas.addEventListener('mouseup', () => handleMouseUp(false));
canvas.addEventListener('mouseleave', () => handleMouseUp(true));

canvas.addEventListener('dblclick', e => {
    if (appState.displayOptions.editMode !== 'points') return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const [xw, yw] = screenToWorld(sx, sy, appState.viewState);
    const newPoints = [...appState.points, [clamp(xw, 0, appState.canvasSize.width), clamp(yw, 0, appState.canvasSize.height), appState.currentMaterial]];
    history.setState(newPoints);
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const [wx, wy] = screenToWorld(sx, sy, appState.viewState);
    const k = Math.exp(-e.deltaY * 0.001);
    const oldScale = appState.viewState.scale;
    const newScale = clamp(oldScale * k, SCALE_MIN, SCALE_MAX);
    appState.viewState.scale = newScale;
    appState.viewState.tx = sx - newScale * wx;
    appState.viewState.ty = sy - newScale * wy;
    draw();
});

canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (appState.displayOptions.editMode === 'addPolygon') {
        polygonCreationState.points = [];
        draw();
    }
});


// --- TOOLBAR EVENT HANDLERS ---
document.getElementById('show-fill-checkbox').addEventListener('change', e => { appState.displayOptions.showFill = e.target.checked; draw(); });
document.getElementById('show-edges-checkbox').addEventListener('change', e => { appState.displayOptions.showEdges = e.target.checked; draw(); });
document.getElementById('show-sites-checkbox').addEventListener('change', e => { appState.displayOptions.showSites = e.target.checked; draw(); });
document.getElementById('show-heatmap-checkbox').addEventListener('change', e => { appState.displayOptions.showHeatmap = e.target.checked; draw(); });
document.getElementById('show-delaunay-checkbox').addEventListener('change', e => { appState.displayOptions.showDelaunay = e.target.checked; draw(); });

editModeSelect.addEventListener('change', e => {
    polygonCreationState.points = []; // Clear polygon on mode change
    appState.previewPoints = null;
    appState.displayOptions.editMode = e.target.value;
    canvas.style.cursor = getCursorStyle();
    updateGeneratorParamsUI();
    draw();
});

undoBtn.addEventListener('click', () => history.undo());
redoBtn.addEventListener('click', () => history.redo());
document.getElementById('clear-btn').addEventListener('click', () => history.setState([]));
document.getElementById('reset-view-btn').addEventListener('click', () => {
    appState.viewState = { scale: 1, tx: 0, ty: 0 };
    draw();
});
document.getElementById('cull-btn').addEventListener('click', handleRemoveRedundant);
document.getElementById('voxelize-btn').addEventListener('click', handleVoxelizeCurrent);
document.getElementById('export-btn').addEventListener('click', handleExportJson);

const importInput = document.getElementById('import-input');
document.getElementById('import-btn').addEventListener('click', () => importInput.click());
importInput.addEventListener('change', e => {
    if (e.target.files && e.target.files[0]) {
        handleImportJson(e.target.files[0]);
    }
    e.target.value = '';
});

// Modal handlers
helpBtn.addEventListener('click', () => {
  helpModal.classList.remove('hidden');
});

const closeModal = () => {
  helpModal.classList.add('hidden');
};

closeModalBtn.addEventListener('click', closeModal);
helpModal.addEventListener('click', (e) => {
  if (e.target === helpModal) {
    closeModal();
  }
});

// --- LOGIC FUNCTIONS ---
const buildRotGridTemplate = (ang, step, Nx, Ny, offsetX, offsetY, material) => {
    const { reducePoints } = appState.generatorParams;
    const cosA = Math.cos(ang), sinA = Math.sin(ang);
    const T = [];
    const ix0 = -(Nx - 1) / 2, iy0 = -(Ny - 1) / 2;
    if (reducePoints) {
        const ixs = [...new Set([0, 1, Nx - 2, Nx - 1].filter(i => i >= 0 && i < Nx))];
        const iys = [...new Set([0, 1, Ny - 2, Ny - 1].filter(i => i >= 0 && i < Ny))];
        for (const iy of iys) {
            for (const ix of ixs) {
                const isCorner = (ix === 0 && iy === 0) ||
                                 (ix === 0 && iy === Ny - 1) ||
                                 (ix === Nx - 1 && iy === 0) ||
                                 (ix === Nx - 1 && iy === Ny - 1);
                if (isCorner && Nx > 1 && Ny > 1) {
                    continue;
                }
                const x0 = (ix0 + ix) * step, y0 = (iy0 + iy) * step;
                const x = offsetX + (x0 * cosA - y0 * sinA);
                const y = offsetY + (x0 * sinA + y0 * cosA);
                const onFrame = (ix === 0 || ix === Nx - 1 || iy === 0 || iy === Ny - 1);
                T.push([x, y, onFrame ? 0 : material]);
            }
        }
    } else {
        for (let iy = 0; iy < Ny; iy++) {
            for (let ix = 0; ix < Nx; ix++) {
                const x0 = (ix0 + ix) * step, y0 = (iy0 + iy) * step;
                const x = offsetX + (x0 * cosA - y0 * sinA);
                const y = offsetY + (x0 * sinA + y0 * cosA);
                const onFrame = (ix === 0 || ix === Nx - 1 || iy === 0 || iy === Ny - 1);
                T.push([x, y, onFrame ? 0 : material]);
            }
        }
    }
    return T;
};

function buildConcentricTemplate(offsetX, offsetY) {
    const { step, rMin, rMax, spacing, radialAlignment } = appState.generatorParams;
    const pts = [];
    const R_min = Math.max(1, Math.floor(rMin)), R_max = Math.max(R_min, Math.floor(rMax));
    
    const n_aligned = Math.max(1, Math.floor((2 * Math.PI * R_max) / spacing));

    for (let r = R_min; r <= R_max; r++) {
        let n, dtheta;
        if (radialAlignment) {
            n = n_aligned;
            dtheta = (2 * Math.PI) / n;
        } else {
            n = Math.max(1, Math.floor((2 * Math.PI * r) / spacing));
            dtheta = spacing / Math.max(r, 1e-6);
        }

        for (let k = 0; k < n; k++) {
            const th = k * dtheta;
            const x = offsetX + step * r * Math.cos(th);
            const y = offsetY + step * r * Math.sin(th);
            pts.push([x, y, (r === R_max || r === R_min) ? 0 : appState.currentMaterial]);
        }
    }
    return pts;
}

function generateConcentric(offsetX, offsetY) {
    const { width: W, height: H } = appState.canvasSize;
    const { step, rMax, overwrite } = appState.generatorParams;
    const templatePoints = buildConcentricTemplate(offsetX, offsetY);
    const pts = templatePoints.filter(p => p[0] >= 0 && p[0] <= W && p[1] >= 0 && p[1] <= H);
    
    let basePoints = appState.points;
    if (overwrite) {
        const radiusSq = (rMax * step) ** 2;
        basePoints = appState.points.filter(p => {
            const dx = p[0] - offsetX;
            const dy = p[1] - offsetY;
            return dx * dx + dy * dy > radiusSq;
        });
    }
    
    history.setState([...basePoints, ...pts]);
}

function generateGrid(offsetX, offsetY) {
    const { angle, step, nx, ny, overwrite } = appState.generatorParams;
    const { width: W, height: H } = appState.canvasSize;
    const T = buildRotGridTemplate(angle * Math.PI / 180, step, nx, ny, offsetX, offsetY, appState.currentMaterial);
    const pts = T.filter(p => p[0] >= 0 && p[0] <= W && p[1] >= 0 && p[1] <= H);

    let basePoints = appState.points;
    if (overwrite && pts.length > 0) {
        const ang = angle * Math.PI / 180;
        const cosA = Math.cos(ang), sinA = Math.sin(ang);
        const w = (nx - 1) * step, h = (ny - 1) * step;
        const corners = [
            [-w / 2, -h / 2], [w / 2, -h / 2],
            [w / 2, h / 2], [-w / 2, h / 2]
        ].map(([x, y]) => [
            offsetX + (x * cosA - y * sinA),
            offsetY + (x * sinA + y * cosA)
        ]);

        basePoints = appState.points.filter(p => {
            const xp = p[0] - offsetX;
            const yp = p[1] - offsetY;
            // Rotate the point back to the grid's local coordinate system
            const localX = xp * cosA + yp * sinA;
            const localY = -xp * sinA + yp * cosA;
            return Math.abs(localX) > w / 2 || Math.abs(localY) > h / 2;
        });
    }
    
    history.setState([...basePoints, ...pts]);
}

/**
 * Reflects a point across a line defined by two other points.
 * @param {number[]} P - The point to reflect [x, y].
 * @param {number[]} lineP1 - The first point on the line [x, y].
 * @param {number[]} lineP2 - The second point on the line [x, y].
 * @returns {number[]} The reflected point [x, y].
 */
function reflectPoint(P, lineP1, lineP2) {
    const vx = lineP2[0] - lineP1[0];
    const vy = lineP2[1] - lineP1[1];
    const wx = P[0] - lineP1[0];
    const wy = P[1] - lineP1[1];

    const lenSq = vx * vx + vy * vy;
    if (lenSq < 1e-9) { // The two line points are identical
        return [2 * lineP1[0] - P[0], 2 * lineP1[1] - P[1]];
    }

    const t = (wx * vx + wy * vy) / lenSq;
    const projX = lineP1[0] + t * vx;
    const projY = lineP1[1] + t * vy;

    // Reflected point P' = P + 2 * (proj - P) = 2*proj - P
    return [2 * projX - P[0], 2 * projY - P[1]];
}

function subdividePolygon(polygon, offset) {
    if (polygon.length < 2) return polygon;
    const newPolygon = [];
    
    for (let i = 0; i < polygon.length; i++) {
        const p1 = polygon[i];
        const p2 = polygon[(i + 1) % polygon.length];

        newPolygon.push(p1);

        const vx = p2[0] - p1[0];
        const vy = p2[1] - p1[1];
        const length = Math.hypot(vx, vy);

        if (length > offset) {
            const numPointsToAdd = Math.floor(length / offset)-1;
            const normVx = vx / length;
            const normVy = vy / length;

            for (let j = 1; j <= numPointsToAdd; j++) {
                const newX = p1[0] + j * offset * normVx;
                const newY = p1[1] + j * offset * normVy;
                newPolygon.push([newX, newY]);
            }
        }
    }
    return newPolygon;
}

function generatePolygonVertex(polygon, distance) {
  // --- Ensure CCW winding order for consistent inward normals ---
  let area = 0;
  for (let i = 0; i < polygon.length; i++) {
    const p1 = polygon[i];
    const p2 = polygon[(i + 1) % polygon.length];
    area += p1[0] * p2[1] - p2[0] * p1[1];
  }
  if (area < 0) polygon = polygon.slice().reverse();

  const L = distance * 0.5; // L is half the total offset
  const eps = 1e-9;
  let newPoints = [];

  for (let i = 0; i < polygon.length; i++) {
    const A = polygon[i];
    const B = polygon[(i - 1 + polygon.length) % polygon.length];
    const C = polygon[(i + 1) % polygon.length];

    const v_BA = [A[0] - B[0], A[1] - B[1]];
    const len_BA = Math.hypot(v_BA[0], v_BA[1]);
    if (len_BA < eps) continue;
    const e_BA = [v_BA[0] / len_BA, v_BA[1] / len_BA];

    const v_AC = [C[0] - A[0], C[1] - A[1]];
    const len_AC = Math.hypot(v_AC[0], v_AC[1]);
    if (len_AC < eps) continue;
    const e_AC = [v_AC[0] / len_AC, v_AC[1] / len_AC];

    // Determine corner type (convex/concave)
    const cross_product = e_BA[0] * e_AC[1] - e_BA[1] * e_AC[0];
    const isConvex = cross_product > eps;
    
    // Check for near-collinearity
    const dot_product = e_BA[0] * e_AC[0] + e_BA[1] * e_AC[1];
    const matInside = appState.currentMaterial;
    const matOutside = 0;

    if (dot_product > 0.999) { // Handle nearly straight line edge case
        const offset_L = isConvex ? L : -L;
        const n_BA_inward = [-e_BA[1], e_BA[0]];
        const F = [A[0] + n_BA_inward[0] * offset_L, A[1] + n_BA_inward[1] * offset_L];
        const D = reflectPoint(F, A, B);

        if (isConvex) {
            newPoints.push([F[0], F[1], matInside]);
            newPoints.push([D[0], D[1], matOutside]);
        } else { // Concave
            newPoints.push([F[0], F[1], matOutside]);
            newPoints.push([D[0], D[1], matInside]);
        }
    } else { // Standard case for distinct corners
        const offset_L = isConvex ? L : -L;
        const n_BA_inward = [-e_BA[1], e_BA[0]];
        const p1_on_R1 = [A[0] + n_BA_inward[0] * offset_L, A[1] + n_BA_inward[1] * offset_L];

        const n_AC_inward = [-e_AC[1], e_AC[0]];
        const p2_on_R2 = [A[0] + n_AC_inward[0] * offset_L, A[1] + n_AC_inward[1] * offset_L];

        const F = lineLineIntersection(p1_on_R1, e_BA, p2_on_R2, e_AC);
        if (!F) continue; 

        const D = reflectPoint(F, A, B);
        const E = reflectPoint(F, A, C);

        if (isConvex) {
            newPoints.push([F[0], F[1], matInside]);
            newPoints.push([D[0], D[1], matOutside]);
            newPoints.push([E[0], E[1], matOutside]);
        } else { // Concave
            newPoints.push([F[0], F[1], matOutside]);
            newPoints.push([D[0], D[1], matInside]);
            newPoints.push([E[0], E[1], matInside]);
        }
    }
  }

  return newPoints;
}

function generatePolygonRing(polygon, distance) {
    // 1. Ensure CCW winding order for consistent inward normals
    let area = 0;
    for (let i = 0; i < polygon.length; i++) {
        const p1 = polygon[i];
        const p2 = polygon[(i + 1) % polygon.length];
        area += p1[0] * p2[1] - p2[0] * p1[1];
    }
    if (area < 0) polygon = polygon.slice().reverse();

    const L = distance;
    const finalPoints = [];
    const matInside = appState.currentMaterial;
    const matOutside = 0;
    const eps = 1e-9;

    const getInternalBisectorLine = (p_prev, p_corner, p_next) => {
        const v_corner_prev = [p_prev[0] - p_corner[0], p_prev[1] - p_corner[1]];
        const v_corner_next = [p_next[0] - p_corner[0], p_next[1] - p_corner[1]];

        const len1 = Math.hypot(v_corner_prev[0], v_corner_prev[1]);
        const len2 = Math.hypot(v_corner_next[0], v_corner_next[1]);

        if (len1 < eps || len2 < eps) return null;

        const u1 = [v_corner_prev[0] / len1, v_corner_prev[1] / len1];
        const u2 = [v_corner_next[0] / len2, v_corner_next[1] / len2];

        // The vector (u1 + u2) bisects the angle, pointing "outward" from the angle between vectors.
        let bisector_dir = [u1[0] + u2[0], u1[1] + u2[1]];

        // Cross product of sequential edge vectors to determine corner type
        const v_seq1 = [p_corner[0] - p_prev[0], p_corner[1] - p_prev[1]];
        const v_seq2 = [p_next[0] - p_corner[0], p_next[1] - p_corner[1]];
        const cross = v_seq1[0] * v_seq2[1] - v_seq1[1] * v_seq2[0];

        // For a CCW polygon, cross > 0 is a convex ("left turn") corner.
        // The bisector (u1+u2) points "outward". For convex, this is external. Flip for internal.
        if (cross > eps) { // Convex corner
            bisector_dir = [-bisector_dir[0], -bisector_dir[1]];
        }
        
        const len_b = Math.hypot(bisector_dir[0], bisector_dir[1]);
        if (len_b < eps) { // Happens for 180 degree corners (straight line).
            const norm_dir = [-v_seq2[1], v_seq2[0]]; // Inward normal for CCW
            const len_n = Math.hypot(norm_dir[0], norm_dir[1]);
            if (len_n < eps) return null;
            const bisector_dir_norm = [norm_dir[0] / len_n, norm_dir[1] / len_n];
            const line_normal = [-bisector_dir_norm[1], bisector_dir_norm[0]];
            return { point: p_corner, normal: line_normal };
        }

        const bisector_dir_norm = [bisector_dir[0]/len_b, bisector_dir[1]/len_b];
        const line_normal = [-bisector_dir_norm[1], bisector_dir_norm[0]];
        return { point: p_corner, normal: line_normal };
    };

    for (let i = 0; i < polygon.length; i++) {
        const C = polygon[(i - 1 + polygon.length) % polygon.length];
        const A = polygon[i];
        const B = polygon[(i + 1) % polygon.length];
        const D = polygon[(i + 2) % polygon.length];

        // 1. Calculate the internal bisectors at corners A and B
        const bisector_A = getInternalBisectorLine(C, A, B);
        const bisector_B = getInternalBisectorLine(A, B, D);
        if (!bisector_A || !bisector_B) continue;

        const seg_vec = [B[0] - A[0], B[1] - A[1]];
        const seg_len = Math.hypot(seg_vec[0], seg_vec[1]);
        if (seg_len < eps) continue;

        const seg_dir = [seg_vec[0] / seg_len, seg_vec[1] / seg_len];
        const seg_norm_inward = [-seg_dir[1], seg_dir[0]];

        // 2. Define which side of each bisector line is "valid"
        const side_check_A = (B[0] - A[0]) * bisector_A.normal[0] + (B[1] - A[1]) * bisector_A.normal[1];
        const side_check_B = (A[0] - B[0]) * bisector_B.normal[0] + (A[1] - B[1]) * bisector_B.normal[1];

        // 3. Iterate along the segment, generating and testing points
        for (let dist = -L; dist <= seg_len+L; dist += L) {
            const P_mid = [A[0] + dist * seg_dir[0], A[1] + dist * seg_dir[1]];
            const P_int = [P_mid[0] + L * seg_norm_inward[0], P_mid[1] + L * seg_norm_inward[1]];
            const P_ext = [P_mid[0] - L * seg_norm_inward[0], P_mid[1] - L * seg_norm_inward[1]];

            const candidates = [
                { point: P_mid, material: matInside },
                { point: P_int, material: matOutside },
                { point: P_ext, material: matOutside },
            ];

            for (const { point: P, material } of candidates) {
                // Dot product determines which side of the line a point is on.
                const dot_A = (P[0] - A[0]) * bisector_A.normal[0] + (P[1] - A[1]) * bisector_A.normal[1];
                const dot_B = (P[0] - B[0]) * bisector_B.normal[0] + (P[1] - B[1]) * bisector_B.normal[1];

                // Point is valid if it's on the same side as the reference point for BOTH bisectors.
                const is_valid_A = (dot_A * side_check_A >= -eps);
                const is_valid_B = (dot_B * side_check_B >= -eps);

                if (is_valid_A && is_valid_B) {
                    finalPoints.push([P[0], P[1], material]);
                }
            }
        }
    }

    return finalPoints;
}


function generatePolygonVoronoi(polygon, distance) {
  if (!Array.isArray(polygon) || polygon.length < 3) return;

  let newPoints;
  if (appState.generatorParams.polygonRing) {
    newPoints = generatePolygonRing(polygon, distance);
  } else {
    newPoints = generatePolygonVertex(polygon, distance);
  }

  let basePoints = appState.points;
  if (appState.generatorParams.overwrite) {
      basePoints = appState.points.filter(p => {
          // Point-in-polygon test
          let inside = false;
          for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
              const xi = polygon[i][0], yi = polygon[i][1];
              const xj = polygon[j][0], yj = polygon[j][1];
              const intersect = ((yi > p[1]) != (yj > p[1])) && (p[0] < (xj - xi) * (p[1] - yi) / (yj - yi) + xi);
              if (intersect) inside = !inside;
          }
          return !inside;
      });
  }

  history.setState([...basePoints, ...newPoints]);
}


function handleAddShape(worldX, worldY) {
    if (appState.displayOptions.editMode === 'addCircle') generateConcentric(worldX, worldY);
    else if (appState.displayOptions.editMode === 'addGrid') generateGrid(worldX, worldY);
    appState.displayOptions.editMode = 'pan';
    editModeSelect.value = 'pan';
    canvas.style.cursor = getCursorStyle();
    updateGeneratorParamsUI();
}

function handleAddPolygonPoint(worldX, worldY) {
    const points = polygonCreationState.points;
    if (points.length > 1) {
        const firstPoint = points[0];
        const distSq = (firstPoint[0] - worldX)**2 + (firstPoint[1] - worldY)**2;
        // Close polygon if click is near the start
        if (distSq < (20 / appState.viewState.scale)**2) {
            const distance = appState.generatorParams.polygonPointDistance;
            let polygonToGenerate = points;
            if (appState.generatorParams.splitEdges && !appState.generatorParams.polygonRing) {
                polygonToGenerate = subdividePolygon(points, distance);
            }
            generatePolygonVoronoi(polygonToGenerate, distance);
            polygonCreationState.points = [];
            // Switch back to pan mode after creation
            appState.displayOptions.editMode = 'pan';
            editModeSelect.value = 'pan';
            canvas.style.cursor = getCursorStyle();
            updateGeneratorParamsUI();
            return;
        }
    }
    points.push([worldX, worldY]);
}

function handleVoxelizeCurrent() {
    if (appState.points.length === 0) return alert("Cannot voxelize an empty set of points.");
    const { width: W, height: H } = appState.canvasSize;
    const S = 20, newPoints = [], COLS = Math.ceil(W / S), ROWS = Math.ceil(H / S);
    for (let yi = 0; yi < ROWS; yi++) {
        for (let xi = 0; xi < COLS; xi++) {
            const cellCenterX = xi * S + S * 0.5, cellCenterY = yi * S + S * 0.5;
            let nearestPointIndex = -1, minDistanceSq = Infinity;
            for (let i = 0; i < appState.points.length; i++) {
                const p = appState.points[i];
                const distSq = (p[0] - cellCenterX) ** 2 + (p[1] - cellCenterY) ** 2;
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    nearestPointIndex = i;
                }
            }
            if (nearestPointIndex === -1) continue;
            const [pxRaw, pyRaw, m] = appState.points[nearestPointIndex];
            const px = clamp(pxRaw, xi * S + 0.01, Math.min(xi * S + S - 0.01, W));
            const py = clamp(pyRaw, yi * S + 0.01, Math.min(yi * S + S - 0.01, H));
            newPoints.push([px, py, m]);
        }
    }
    history.setState(newPoints);
}

function handleRemoveRedundant() {
    if (appState.points.length < 2) return;
    const adj = Array(appState.points.length).fill(0).map(() => []), edgeMap = new Map();
    const PRECISION = 3;
    appState.cells.forEach((poly, i) => {
        if (!poly || poly.length < 2) return;
        for (let k = 0; k < poly.length; k++) {
            const p1 = poly[k], p2 = poly[(k + 1) % poly.length];
            const p1s = `${p1[0].toFixed(PRECISION)},${p1[1].toFixed(PRECISION)}`;
            const p2s = `${p2[0].toFixed(PRECISION)},${p2[1].toFixed(PRECISION)}`;
            const key = p1s < p2s ? `${p1s}:${p2s}` : `${p2s}:${p1s}`;
            const edgeIndices = edgeMap.get(key) || [];
            edgeIndices.push(i);
            edgeMap.set(key, edgeIndices);
        }
    });
    for (const indices of edgeMap.values()) {
        if (indices.length === 2) {
            const [i, j] = indices;
            adj[i].push(j);
            adj[j].push(i);
        }
    }
    const pointsToRemove = new Set();
    for (let i = 0; i < appState.points.length; i++) {
        const currentMaterial = appState.points[i][2];
        const neighbors = [...new Set(adj[i])];
        if (neighbors.length > 0 && neighbors.every(nIdx => appState.points[nIdx][2] === currentMaterial)) {
            pointsToRemove.add(i);
        }
    }
    if (pointsToRemove.size > 0) {
        history.setState(appState.points.filter((_, i) => !pointsToRemove.has(i)));
    }
}

function handleExportJson() {
    const jsonString = JSON.stringify(appState.points, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'points.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function handleImportJson(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const text = e.target?.result;
            if (typeof text !== 'string') throw new Error('File could not be read.');
            const arr = JSON.parse(text);
            if (!Array.isArray(arr)) throw new Error('Invalid JSON format: not an array.');
            
            const validatedPoints = arr.map(p => {
                if (!Array.isArray(p) || p.length < 2) return null;
                return [
                    typeof p[0] === 'number' ? p[0] : 0,
                    typeof p[1] === 'number' ? p[1] : 0,
                    p.length >= 3 && typeof p[2] === 'number' ? p[2] : 1
                ];
            }).filter(p => p !== null);
            history.setState(validatedPoints);
        } catch (err) {
            alert(`Invalid JSON: ${err.message || String(err)}`);
        }
    };
    reader.onerror = () => alert('Error reading file.');
    reader.readAsText(file);
}

function handleKeyDown(e) {
    const mode = appState.displayOptions.editMode;
    if (mode !== 'addCircle' && mode !== 'addGrid') return;

    let changed = false;
    const params = appState.generatorParams;

    switch (e.key) {
        case 'ArrowUp':
            changed = true;
            if (mode === 'addCircle') {
                params.rMax = clamp(params.rMax + 1, params.rMin, 20);
            } else if (mode === 'addGrid') {
                params.angle = clamp(params.angle + 10, -90, 90);
            }
            break;
        case 'ArrowDown':
            changed = true;
            if (mode === 'addCircle') {
                params.rMax = clamp(params.rMax - 1, params.rMin, 20);
            } else if (mode === 'addGrid') {
                params.angle = clamp(params.angle - 10, -90, 90);
            }
            break;
        case 'ArrowRight':
            changed = true;
            if (mode === 'addCircle') {
                params.rMin = clamp(params.rMin + 1, 1, params.rMax);
            } else if (mode === 'addGrid') {
                params.nx = clamp(params.nx + 1, 1, 50);
            }
            break;
        case 'ArrowLeft':
            changed = true;
            if (mode === 'addCircle') {
                params.rMin = clamp(params.rMin - 1, 1, params.rMax);
            } else if (mode === 'addGrid') {
                params.nx = clamp(params.nx - 1, 1, 50);
            }
            break;
    }

    if (changed) {
        e.preventDefault();
        updateGeneratorParamsUI();

        // Update preview if active (mouse is over canvas)
        if (appState.previewPoints) {
            const { x: xw, y: yw } = interactionState.mouseWorldPos;
            if (mode === 'addCircle') {
                appState.previewPoints = buildConcentricTemplate(xw, yw);
            } else { // addGrid
                appState.previewPoints = buildRotGridTemplate(params.angle * Math.PI / 180, params.step, params.nx, params.ny, xw, yw, appState.currentMaterial);
            }
            draw();
        }
    }
}

// --- UI HELPERS ---
function getCursorStyle() {
    switch (appState.displayOptions.editMode) {
        case 'pan': return 'grab';
        case 'addCircle': case 'addGrid': return 'crosshair';
        case 'addPolygon': return 'crosshair';
        default: return 'default';
    }
}

function updateGeneratorParamsUI() {
  const mode = appState.displayOptions.editMode;
  let html = '';
  if (mode === 'addCircle' || mode === 'addGrid' || mode === 'addPolygon') {
    html += `<label class="flex items-center gap-2 cursor-pointer col-span-full"><input type="checkbox" name="overwrite" ${appState.generatorParams.overwrite ? 'checked' : ''} /> <span>Overwrite Existing</span></label>`;
    if (mode === 'addCircle' || mode === 'addGrid') {
        html += `<label class="flex flex-col min-w-[180px]"><span>Step / Scale: ${appState.generatorParams.step}</span><input class="w-full" type="range" name="step" min="5" max="100" value="${appState.generatorParams.step}" /></label>`;
    }
    if (mode === 'addCircle') {
      html += `<label class="flex flex-col min-w-[180px]"><span>rMin: ${appState.generatorParams.rMin}</span><input class="w-full" type="range" name="rMin" min="1" max="20" value="${appState.generatorParams.rMin}" /></label>`;
      html += `<label class="flex flex-col min-w-[180px]"><span>rMax: ${appState.generatorParams.rMax}</span><input class="w-full" type="range" name="rMax" min="1" max="20" value="${appState.generatorParams.rMax}" /></label>`;
      html += `<label class="flex flex-col min-w-[180px]"><span>Spacing: ${appState.generatorParams.spacing}</span><input class="w-full" type="range" name="spacing" min="0.1" max="5" step="0.1" value="${appState.generatorParams.spacing}" /></label>`;
      html += `<label class="flex items-center gap-2 cursor-pointer col-span-full"><input type="checkbox" name="radialAlignment" ${appState.generatorParams.radialAlignment ? 'checked' : ''} /> <span>Radial Alignment</span></label>`;
    } else if (mode === 'addGrid') { 
      html += `<label class="flex flex-col min-w-[180px]"><span>Angle: ${appState.generatorParams.angle}</span><input class="w-full" type="range" name="angle" min="-90" max="90" value="${appState.generatorParams.angle}" /></label>`;
      html += `<label class="flex flex-col min-w-[180px]"><span>Nx: ${appState.generatorParams.nx}</span><input class="w-full" type="range" name="nx" min="1" max="50" value="${appState.generatorParams.nx}" /></label>`;
      html += `<label class="flex flex-col min-w-[180px]"><span>Ny: ${appState.generatorParams.ny}</span><input class="w-full" type="range" name="ny" min="1" max="50" value="${appState.generatorParams.ny}" /></label>`;
      html += `<label class="flex items-center gap-2 cursor-pointer col-span-full"><input type="checkbox" name="reducePoints" ${appState.generatorParams.reducePoints ? 'checked' : ''} /> <span>Reduce Points</span></label>`;
    } else if (mode === 'addPolygon') {
      html += `<label class="flex flex-col min-w-[180px]"><span>Point Distance: ${appState.generatorParams.polygonPointDistance}</span><input class="w-full" type="range" name="polygonPointDistance" min="2" max="100" value="${appState.generatorParams.polygonPointDistance}" /></label>`;
      html += `<label class="flex items-center gap-2 cursor-pointer col-span-full"><input type="checkbox" name="splitEdges" ${appState.generatorParams.splitEdges ? 'checked' : ''} /> <span>Split Edges</span></label>`;
      html += `<label class="flex items-center gap-2 cursor-pointer col-span-full"><input type="checkbox" name="polygonRing" ${appState.generatorParams.polygonRing ? 'checked' : ''} /> <span>Generate as Ring</span></label>`;
    }
  } else {
    html = `<p class="text-gray-400">Select 'Add Circle', 'Add Grid', or 'Add Polygon' mode to see shape parameters.</p>`;
  }
  genParamsContainer.innerHTML = html;
}

genParamsContainer.addEventListener('input', e => {
    const target = e.target;
    if (target.type === 'range') {
        const params = appState.generatorParams;
        const name = target.name;
        const value = Number(target.value);
        params[name] = value;

        // Ensure rMin <= rMax
        if (name === 'rMin' && value > params.rMax) {
            params.rMax = value;
        } else if (name === 'rMax' && value < params.rMin) {
            params.rMin = value;
        }

        updateGeneratorParamsUI();
    } else if (target.type === 'checkbox') {
        appState.generatorParams[target.name] = target.checked;
        updateGeneratorParamsUI(); // Re-render to ensure any dependent UI updates
    }
});


// --- INITIALIZATION ---
function init() {
  // Setup canvas size
  const resizeObserver = new ResizeObserver(entries => {
    if (!entries || entries.length === 0) return;
    const { width: newWidth, height: newHeight } = entries[0].contentRect;

    if (newWidth <= 0 || newHeight <= 0) return;

    // Defer resize logic to the next animation frame to prevent "ResizeObserver loop" errors.
    window.requestAnimationFrame(() => {
      if (appState.canvasSize.width !== newWidth || appState.canvasSize.height !== newHeight) {
        appState.canvasSize.width = newWidth;
        appState.canvasSize.height = newHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(appState.canvasSize.width * dpr);
        canvas.height = Math.round(appState.canvasSize.height * dpr);
        canvas.style.width = `${appState.canvasSize.width}px`;
        canvas.style.height = `${appState.canvasSize.height}px`;
        updateApp();
      }
    });
  });
  resizeObserver.observe(canvasContainer);

  // Setup material selector
  materialSelector.innerHTML = MATERIAL_COLORS.map((color, i) => `
    <button
      class="w-6 h-6 rounded border-2 border-transparent hover:border-gray-400 ring-offset-2 ring-offset-gray-800 ring-blue-500"
      style="background-color: ${color}"
      title="Material ${i}"
      data-material-id="${i}"
    ></button>
  `).join('');
  
  materialSelector.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (btn) {
          appState.currentMaterial = Number(btn.dataset.materialId);
          updateApp();
      }
  });

  document.addEventListener('keydown', handleKeyDown);

  // Initial UI state
  editModeSelect.value = appState.displayOptions.editMode;
  canvas.style.cursor = getCursorStyle();
  updateGeneratorParamsUI();
  updateApp(); // Initial render
}

init();


    </script>
</body>
</html>